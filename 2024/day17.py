import aocd
import re

EXAMPLE = """
Register A: 729
Register B: 0
Register C: 0

Program: 0,1,5,4,3,0
""".strip()

def run(instructions, registers):

    def combo_operand(operand):

        if 0 <= operand <= 3:
            return operand
        elif operand == 4:
            return registers["A"]
        elif operand == 5:
            return registers["B"]
        elif operand == 6:
            return registers["C"]
        elif operand == 7:
            raise Exception("Operand 7 will not appear in valid instructions.")
        else:
            raise Exception(f"Unknown operand {operand}")

    instruction_pointer = 0
    outputs = []

    while instruction_pointer < len(instructions) - 1:

        opcode = instructions[instruction_pointer]
        operand = instructions[instruction_pointer + 1]

        # adv
        if opcode == 0:
            registers["A"] = int(registers["A"] / 2 ** combo_operand(operand))
        
        # bxl
        elif opcode == 1:
            registers["B"] = registers["B"] ^ operand
        
        # bst
        elif opcode == 2:
            registers["B"] = combo_operand(operand) % 8
        
        # jnz
        elif opcode == 3:
            if registers["A"] == 0:
                pass
            else:
                instruction_pointer = operand
                continue
        
        # bxc
        elif opcode == 4:
            registers["B"] = registers["B"] ^ registers["C"]
        
        # out
        elif opcode == 5:
            outputs += [combo_operand(operand) % 8]
        
        # bdv
        elif opcode == 6:
            registers["B"] = int(registers["A"] / 2 ** combo_operand(operand))
        
        # cdv
        elif opcode == 7:
            registers["C"] = int(registers["A"] / 2 ** combo_operand(operand))
        
        else:
            raise Exception(f"Unknown opcode {opcode}")


        instruction_pointer += 2

    return ",".join([str(n) for n in outputs])

def parse_input(_in):

    program = []
    registers = {}
    for line in _in.split("\n"):
        line = line.strip()

        if not line:
            continue

        match = re.match(r"Register ([A-Z]): (\d+)", line)
        if match:
            registers[match.group(1)] = int(match.group(2))
            continue
        
        match = re.match(r"Program: (.*)", line)
        if match:
            program = [int(n) for n in re.findall(r"\d+", line)]
            continue

        raise Exception(f"Unknown line: {line}")

    return program, registers

def crack_code(program, registers):

    # There is a pattern in the code. So you can search much
    # faster using the pattern. The leading octet determines
    # what the last number in the output of the program will
    # be. The second octet will determine the second to last
    # and so on.
    #
    # So we will increment by one until we find the desired
    # output, then we will shift the octal over by 8 and
    # increment again to find the next desired output. We
    # will repeat until we generate the correct value.
    #
    # The pattern can be generated by incrementing the A
    # register by one and then outputing the value of the
    # A register (in ocatal) and the resulting program

    target = ",".join([str(n) for n in program])
    current_target = str(program[-1])
    current_target_index = len(program) - 1
    current = 1
    while True:

        registers["A"] = current
        output = run(program, registers)
        
        if output == target:
            break
        elif output == current_target:
            current = current * 8
            current_target_index -= 1
            current_target = ",".join([str(n) for n in program[current_target_index:]])
        else:
            current += 1

    return current

if __name__ == "__main__":

    _in = EXAMPLE
    _in = aocd.get_data(year = 2024, day = 17)

    # Parse Input
    program, registers = parse_input(_in)

    # Part 1
    print(run(program, registers))

    # Part 2
    print(crack_code(program, registers))